import type { MaybePromise } from '../utils';
import type { KeystoneContextFromSchemaCccTypeInfo } from '..';
import { BaseSchemaCccTypeInfo } from '../type-info';

type BaseAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> = {
  session: any;
  schemaCccKey: string;
  context: KeystoneContextFromSchemaCccTypeInfo<SchemaCccTypeInfo>;
};

// List Filter Access

type FilterOutput<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  | boolean
  | SchemaCccTypeInfo['inputs']['where'];

export type ListFilterAccessControl<
  Operation extends 'query' | 'update' | 'delete',
  SchemaCccTypeInfo extends BaseSchemaCccTypeInfo
> = (
  args: BaseAccessArgs<SchemaCccTypeInfo> & { operation: Operation }
) => MaybePromise<FilterOutput<SchemaCccTypeInfo>>;

// List Item Access

type CreateItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  BaseAccessArgs<SchemaCccTypeInfo> & {
    operation: 'create';
    /**
     * The input passed in from the GraphQL API
     */
    inputData: SchemaCccTypeInfo['inputs']['create'];
  };

export type CreateListItemAccessControl<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> = (
  args: CreateItemAccessArgs<SchemaCccTypeInfo>
) => MaybePromise<boolean>;

type UpdateItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  BaseAccessArgs<SchemaCccTypeInfo> & {
    operation: 'update';
    /**
     * The item being updated
     */
    item: SchemaCccTypeInfo['item'];
    /**
     * The input passed in from the GraphQL API
     */
    inputData: SchemaCccTypeInfo['inputs']['update'];
  };

export type UpdateListItemAccessControl<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> = (
  args: UpdateItemAccessArgs<SchemaCccTypeInfo>
) => MaybePromise<boolean>;

type DeleteItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  BaseAccessArgs<SchemaCccTypeInfo> & {
    operation: 'delete';
    /**
     * The item being deleted
     */
    item: SchemaCccTypeInfo['item'];
  };

export type DeleteListItemAccessControl<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> = (
  args: DeleteItemAccessArgs<SchemaCccTypeInfo>
) => MaybePromise<boolean>;

export type ListOperationAccessControl<
  Operation extends 'create' | 'query' | 'update' | 'delete',
  SchemaCccTypeInfo extends BaseSchemaCccTypeInfo
> = (args: BaseAccessArgs<SchemaCccTypeInfo> & { operation: Operation }) => MaybePromise<boolean>;

// List level access control lets you set permissions on the autogenerated CRUD API for each list.
//
// * `operation` access lets you check the information in the `context` and `session` objects to decide if the
// user is allow to access the list.
// * `filter` access lets you provide a GraphQL filter which defines the items the user is allowed to access.
// * `item` access lets you write a function which inspects the provided input data and the existing object (if it exists)
// and make a decision based on this extra data.
//
// If access is denied due to any of the access control methods then the following response will be returned from the GraphQL API:
//   Mutations:
//     - Single operations will return `null` and return an access denied error
//     - Multi operations will return a data array with `null` values for the items which have access denied.
//       Access denied errors will be return for each `null` items.
//   Queries:
//     - Single item queries will return `null` with no errors.
//     - Many item queries will filter out those items which have access denied, with no errors.
//     - Count queries will only count those items for which access is not denied, with no errors.
//
export type ListAccessControl<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> = {
  // These functions should return `true` if access is allowed or `false` if access is denied.
  operation?: {
    query?: ListOperationAccessControl<'query', SchemaCccTypeInfo>;
    create?: ListOperationAccessControl<'create', SchemaCccTypeInfo>;
    update?: ListOperationAccessControl<'update', SchemaCccTypeInfo>;
    delete?: ListOperationAccessControl<'delete', SchemaCccTypeInfo>;
  };

  // The 'filter' rules can return either:
  // - a filter. In this case, the operation can proceed, but the filter will be additionally applied when updating/reading/deleting
  //   which may make it appear that some of the items don't exist.
  // - boolean true/false. If false, treated as a filter that never matches.
  filter?: {
    query?: ListFilterAccessControl<'query', SchemaCccTypeInfo>;
    update?: ListFilterAccessControl<'update', SchemaCccTypeInfo>;
    delete?: ListFilterAccessControl<'delete', SchemaCccTypeInfo>;
    // create: not supported: FIXME: Add explicit check that people don't try this.
    // FIXME: Write tests for parseAccessControl.
  };

  // These rules are applied to each item being operated on individually. They return `true` or `false`,
  // and if false, an access denied error will be returned for the individual operation.
  item?: {
    // query: not supported
    create?: CreateListItemAccessControl<SchemaCccTypeInfo>;
    update?: UpdateListItemAccessControl<SchemaCccTypeInfo>;
    delete?: DeleteListItemAccessControl<SchemaCccTypeInfo>;
  };
};

// Field Access
export type IndividualFieldAccessControl<Args> = (args: Args) => MaybePromise<boolean>;

export type FieldCreateItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  CreateItemAccessArgs<SchemaCccTypeInfo> & { fieldKey: string };

export type FieldReadItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  BaseAccessArgs<SchemaCccTypeInfo> & {
    operation: 'read';
    fieldKey: string;
    item: SchemaCccTypeInfo['item'];
  };

export type FieldUpdateItemAccessArgs<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  UpdateItemAccessArgs<SchemaCccTypeInfo> & { fieldKey: string };

export type FieldAccessControl<SchemaCccTypeInfo extends BaseSchemaCccTypeInfo> =
  | {
      read?: IndividualFieldAccessControl<FieldReadItemAccessArgs<SchemaCccTypeInfo>>;
      create?: IndividualFieldAccessControl<FieldCreateItemAccessArgs<SchemaCccTypeInfo>>;
      update?: IndividualFieldAccessControl<FieldUpdateItemAccessArgs<SchemaCccTypeInfo>>;
      // filter?: COMING SOON
      // orderBy?: COMING SOON
    }
  | IndividualFieldAccessControl<
      | FieldCreateItemAccessArgs<SchemaCccTypeInfo>
      | FieldReadItemAccessArgs<SchemaCccTypeInfo>
      | FieldUpdateItemAccessArgs<SchemaCccTypeInfo>
    >;
